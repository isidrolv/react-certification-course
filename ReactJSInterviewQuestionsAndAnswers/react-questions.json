[
	{"id": 1, "category": "Basics of React", "question": "What is ReactJS?", "options": ["It's a framework for develop Backend components.", "It’s a library of JavaScript and TypeScript components created to help developers build fast UIs with a consistent and flexible architecture, and provides strong mechanisms to beautify the UI with ease.", "It is a Java-based component set with strong UI features developed on backend for the frontend.", "It’s a modern NoSQL database."], "answer": "b", "explanation": "ReactJS is a frontend JavaScript library developed by Facebook, designed to build dynamic and interactive user interfaces efficiently, especially for single-page applications."},
	{"id": 2, "category": "Basics of React", "question": "Who developed ReactJS?", "options": ["Google", "Microsoft", "Facebook (now Meta)", "Twitter"], "answer": "c", "explanation": "ReactJS was created by Jordan Walke, a software engineer at Facebook, and released in 2013."},
	{"id": 3, "category": "Basics of React", "question": "Is ReactJS a framework or a library?", "options": ["A full-stack framework", "A frontend framework", "A library for building UIs", "A database driver"], "answer": "c", "explanation": "ReactJS is technically a library, not a full framework. It focuses mainly on the view layer (UI) in the MVC architecture."},
	{"id": 4, "category": "Basics of React", "question": "What are the main features of React?", "options": ["Virtual DOM, Component-Based, Declarative UI", "Routing, Database, ORM", "Security, Authentication, Sessions", "File System, CLI, Debugging"], "answer": "a", "explanation": "ReactJS uses a Virtual DOM to improve performance, has a component-based architecture, and promotes declarative programming."},
	{"id": 5, "category": "Basics of React", "question": "What is JSX?", "options": ["A special syntax extension that allows writing HTML-like code in JavaScript.", "A backend templating engine for NodeJS.", "A JSON parser for React.", "A styling language for UI components."], "answer": "a", "explanation": "JSX (JavaScript XML) allows developers to write HTML elements directly in JavaScript, making UI code more readable and expressive."},
	{"id": 6, "category": "Basics of React", "question": "Why use JSX?", "options": ["It improves debugging and UI readability.", "It runs faster than plain JavaScript.", "It allows backend API calls.", "It compiles directly to C++."], "answer": "a", "explanation": "JSX improves developer productivity by making code more intuitive and closer to HTML. JSX compiles into React.createElement() calls."},
	{"id": 7, "category": "Basics of React", "question": "Which company maintains ReactJS?", "options": ["Microsoft", "Facebook (Meta)", "Oracle", "IBM"], "answer": "b", "explanation": "ReactJS is maintained by Meta and a large open-source community."},
	{"id": 8, "category": "Basics of React", "question": "What does Virtual DOM mean?", "options": ["A real DOM stored in the cloud.", "A lightweight copy of the real DOM used to optimize updates.", "A relational database for UI.", "An API for styling."], "answer": "b", "explanation": "Virtual DOM is a lightweight representation of the real DOM. React updates the virtual DOM first and then efficiently updates only the changed parts in the real DOM."},
	{"id": 9, "category": "Basics of React", "question": "What is the difference between Real DOM and Virtual DOM?", "options": ["Real DOM is faster than Virtual DOM.", "Virtual DOM updates the entire page each time.", "Virtual DOM is a lightweight copy of Real DOM, allowing optimized updates.", "They are the same thing."], "answer": "c", "explanation": "Updating the Real DOM is slow, but the Virtual DOM optimizes re-renders by calculating diffs and updating only changed nodes."},
	{"id": 10, "category": "Basics of React", "question": "Which of the following is true about ReactJS?", "options": ["React is only for mobile apps.", "React is unidirectional in data flow.", "React is only for desktop applications.", "React requires Java backend."], "answer": "b", "explanation": "React enforces one-way data binding, meaning data flows from parent to child components, making the UI predictable."},
	{"id": 11, "category": "Components", "question": "What are React components?", "options": ["Database queries.", "Independent, reusable pieces of UI.", "Backend services.", "Network requests."], "answer": "b", "explanation": "React components are reusable UI blocks that define how a part of the interface should look and behave."},
	{"id": 12, "category": "Components", "question": "What are the two types of components in React?", "options": ["Functional and Class components.", "Static and Dynamic components.", "Local and Global components.", "Synchronous and Asynchronous components."], "answer": "a", "explanation": "React supports Functional components (simpler, use hooks) and Class components (older, use lifecycle methods)."},
	{"id": 13, "category": "Components", "question": "What is a functional component?", "options": ["A class-based UI structure.", "A function that returns JSX.", "A middleware function in Node.js.", "A styling method."], "answer": "b", "explanation": "Functional components are JavaScript functions that return JSX, representing UI."},
	{"id": 14, "category": "Components", "question": "What is a class component?", "options": ["A component defined as a class extending React.Component.", "A database schema.", "A CSS class.", "An HTML form."], "answer": "a", "explanation": "Class components extend React.Component and use methods like render() to return JSX."},
	{"id": 15, "category": "Components", "question": "Which type of component is preferred in modern React?", "options": ["Class components", "Functional components with Hooks", "Database components", "XML components"], "answer": "b", "explanation": "Functional components with Hooks are now the preferred way, as they are simpler and more efficient."},
	{"id": 16, "category": "Components", "question": "How do you create a functional component?", "options": ["function MyComponent() { return <h1>Hello</h1>; }", "class MyComponent {}", "def MyComponent():", "component MyComponent()"], "answer": "a", "explanation": "Functional components are simple functions returning JSX."},
	{"id": 17, "category": "Components", "question": "How do you create a class component?", "options": ["class MyComponent extends React.Component { render() { return <h1>Hello</h1>; } }", "def MyComponent():", "component MyComponent()", "React.create(MyComponent)"], "answer": "a", "explanation": "Class components extend React.Component and implement the render() method."},
	{"id": 18, "category": "Components", "question": "What is props in React?", "options": ["Properties passed to components.", "A backend API.", "A type of hook.", "A CSS class."], "answer": "a", "explanation": "Props are inputs passed from a parent component to a child, making components reusable."},
	{"id": 19, "category": "Components", "question": "What are default props?", "options": ["Global settings for all apps.", "Fallback values for props if not provided.", "Props stored in Redux.", "Props from backend."], "answer": "b", "explanation": "Default props define fallback values if no prop is passed."},
	{"id": 20, "category": "Components", "question": "What are propTypes in React?", "options": ["A database schema for props.", "A type-checking feature for component props.", "A CSS property.", "A backend type system."], "answer": "b", "explanation": "propTypes are used to enforce type checking for props, helping developers catch errors."},
	{"id": 21, "category": "State & Lifecycle", "question": "What is state in React?", "options": ["A database.", "An object that holds dynamic data in a component.", "A CSS style.", "A server session."], "answer": "b", "explanation": "State is a local, mutable data storage inside a component."},
	{"id": 22, "category": "State & Lifecycle", "question": "How do you initialize state in a class component?", "options": ["this.state = { count: 0 } inside the constructor.", "this.setState = {}", "useState(0)", "state.init()"], "answer": "a", "explanation": "Class components initialize state in the constructor with this.state = {}."},
	{"id": 23, "category": "State & Lifecycle", "question": "How do you update state in a class component?", "options": ["this.state.count = 1", "this.setState({ count: 1 })", "setState.count(1)", "update.state(1)"], "answer": "b", "explanation": "State must be updated using this.setState() to trigger re-renders."},
	{"id": 24, "category": "State & Lifecycle", "question": "How do you create state in a functional component?", "options": ["this.state = {}", "useState(initialValue)", "setState()", "state.init()"], "answer": "b", "explanation": "Functional components use the useState hook to manage state."},
	{"id": 25, "category": "State & Lifecycle", "question": "What are React lifecycle methods?", "options": ["Methods for API calls.", "Methods that define different phases of a component’s life.", "CSS lifecycle rules.", "Redux actions."], "answer": "b", "explanation": "Lifecycle methods are special methods in class components that run at specific phases (mounting, updating, unmounting)."},
	{"id": 26, "category": "State & Lifecycle", "question": "Which lifecycle method is used to fetch data after component mounts?", "options": ["componentDidMount()", "render()", "componentWillUnmount()", "shouldComponentUpdate()"], "answer": "a", "explanation": "componentDidMount() is called once after the component mounts, ideal for API calls."},
	{"id": 27, "category": "State & Lifecycle", "question": "Which lifecycle method is used before a component is removed?", "options": ["componentWillUnmount()", "componentDidMount()", "render()", "shouldComponentUpdate()"], "answer": "a", "explanation": "componentWillUnmount() is called before the component is destroyed, often used for cleanup."},
	{"id": 28, "category": "State & Lifecycle", "question": "Which method is required in a class component?", "options": ["render()", "componentDidMount()", "constructor()", "setState()"], "answer": "a", "explanation": "Every class component must implement the render() method."},
	{"id": 29, "category": "State & Lifecycle", "question": "How do hooks relate to lifecycle methods?", "options": ["They replace lifecycle methods in functional components.", "They are only for Redux.", "They work only in class components.", "They are not related."], "answer": "a", "explanation": "Hooks like useEffect replicate lifecycle behavior (mounting, updating, unmounting) in functional components."},
	{"id": 30, "category": "State & Lifecycle", "question": "Which hook replaces componentDidMount in functional components?", "options": ["useEffect with empty dependency array", "useState", "useReducer", "useRef"], "answer": "a", "explanation": "useEffect(() => {...}, []) runs only once, mimicking componentDidMount."},
	{"id": 31, "category": "Hooks", "question": "What are React hooks?", "options": ["Functions that let functional components use state and lifecycle features.", "CSS features.", "Redux actions.", "Database calls."], "answer": "a", "explanation": "Hooks allow functional components to use features previously only available in class components."},
	{"id": 32, "category": "Hooks", "question": "When were hooks introduced?", "options": ["React 12", "React 16.8", "React 15", "React Native release"], "answer": "b", "explanation": "Hooks were introduced in React 16.8."},
	{"id": 33, "category": "Hooks", "question": "Which hook is used for state management?", "options": ["useState", "useEffect", "useRef", "useReducer"], "answer": "a", "explanation": "useState provides state variables in functional components."},
	{"id": 34, "category": "Hooks", "question": "Which hook is used for side effects?", "options": ["useState", "useEffect", "useRef", "useContext"], "answer": "b", "explanation": "useEffect handles side effects like data fetching, subscriptions, and DOM manipulations."},
	{"id": 35, "category": "Hooks", "question": "Which hook is used for references?", "options": ["useRef", "useState", "useEffect", "useMemo"], "answer": "a", "explanation": "useRef creates mutable references that persist across renders."},
	{"id": 36, "category": "Hooks", "question": "Which hook is used for memoization?", "options": ["useMemo", "useReducer", "useEffect", "useRef"], "answer": "a", "explanation": "useMemo caches the result of a computation to avoid unnecessary recalculations."},
	{"id": 37, "category": "Hooks", "question": "Which hook is used for context?", "options": ["useContext", "useRef", "useMemo", "useEffect"], "answer": "a", "explanation": "useContext allows functional components to consume values from React Context."},
	{"id": 38, "category": "Hooks", "question": "Which hook is used for reducers?", "options": ["useReducer", "useContext", "useEffect", "useRef"], "answer": "a", "explanation": "useReducer is an alternative to useState for complex state logic."},
	{"id": 39, "category": "Hooks", "question": "What rules must hooks follow?", "options": ["Only call hooks at the top level of functional components.", "Only call hooks inside React components or custom hooks.", "Never call hooks in loops or conditions.", "All of the above."], "answer": "d", "explanation": "Hooks have strict rules to ensure consistent execution order."},
	{"id": 40, "category": "Hooks", "question": "Can hooks be used in class components?", "options": ["Yes", "No", "Only with plugins", "Only in Next.js"], "answer": "b", "explanation": "Hooks are designed only for functional components."},
	{"id": 41, "category": "Advanced React", "question": "What is React Context?", "options": ["A database.", "A way to share data across components without props drilling.", "A lifecycle method.", "A CSS class."], "answer": "b", "explanation": "Context allows passing data globally without prop drilling."},
	{"id": 42, "category": "Advanced React", "question": "What is Redux?", "options": ["A CSS library.", "A state management library often used with React.", "A lifecycle hook.", "A routing system."], "answer": "b", "explanation": "Redux is a predictable state container often used for global state in React."},
	{"id": 43, "category": "Advanced React", "question": "What are React Fragments?", "options": ["A way to group elements without extra DOM nodes.", "A state hook.", "A lifecycle method.", "A CSS framework."], "answer": "a", "explanation": "Fragments let you group children without adding extra <div> elements."},
	{"id": 44, "category": "Advanced React", "question": "What are Higher-Order Components (HOCs)?", "options": ["Components wrapped with CSS.", "Functions that take a component and return a new component.", "Redux actions.", "Database queries."], "answer": "b", "explanation": "HOCs add additional functionality to existing components."},
	{"id": 45, "category": "Advanced React", "question": "What is React Router used for?", "options": ["Styling components.", "Handling navigation in single-page applications.", "Fetching APIs.", "Database connections."], "answer": "b", "explanation": "React Router manages navigation without reloading the page."},
	{"id": 46, "category": "Advanced React", "question": "What are controlled components?", "options": ["Components controlled by CSS.", "Form components whose values are controlled by React state.", "Components from Redux.", "Database-driven components."], "answer": "b", "explanation": "Controlled components store input values in state, making them React-controlled."},
	{"id": 47, "category": "Advanced React", "question": "What are uncontrolled components?", "options": ["Components not used in production.", "Form elements that handle their own state internally.", "Redux components.", "Stateless components."], "answer": "b", "explanation": "Uncontrolled components manage their own state via the DOM, not React."},
	{"id": 48, "category": "Advanced React", "question": "What is React reconciliation?", "options": ["Merging databases.", "The process of updating the DOM by comparing Virtual DOM and Real DOM.", "A lifecycle method.", "A CSS update."], "answer": "b", "explanation": "Reconciliation is React’s diffing algorithm that updates only changed elements."},
	{"id": 49, "category": "Advanced React", "question": "What is React Fiber?", "options": ["A CSS framework.", "The new React reconciliation algorithm introduced in React 16.", "A database.", "A lifecycle method."], "answer": "b", "explanation": "Fiber is the new core algorithm introduced in React 16 to handle rendering more efficiently."},
	{"id": 50, "category": "Advanced React", "question": "What is code splitting in React?", "options": ["Dividing CSS files.", "Splitting code into smaller bundles for performance.", "Dividing database queries.", "Lifecycle splitting."], "answer": "b", "explanation": "Code splitting optimizes loading by delivering only the code needed for a given route/component."},
	{"id": 51, "category": "Testing & Performance", "question": "How do you test React components?", "options": ["Using Jest and React Testing Library.", "Using SQL queries.", "Using NodeJS only.", "Manual inspection only."], "answer": "a", "explanation": "Jest and React Testing Library are popular testing tools for React."},
	{"id": 52, "category": "Testing & Performance", "question": "What is shallow rendering?", "options": ["Rendering the entire component tree.", "Rendering a component without its child components.", "Rendering database.", "Rendering CSS."], "answer": "b", "explanation": "Shallow rendering tests a component in isolation, ignoring its children."},
	{"id": 53, "category": "Testing & Performance", "question": "What is React.StrictMode?", "options": ["A debugging tool for highlighting potential problems.", "A CSS library.", "A lifecycle method.", "A state hook."], "answer": "a", "explanation": "StrictMode helps detect unsafe lifecycle methods and potential issues."},
	{"id": 54, "category": "Testing & Performance", "question": "What is lazy loading in React?", "options": ["Loading data slowly.", "Loading components only when needed.", "Loading Redux state.", "Loading CSS."], "answer": "b", "explanation": "Lazy loading improves performance by loading components only when required."},
	{"id": 55, "category": "Testing & Performance", "question": "What is memoization in React?", "options": ["Storing CSS values.", "Optimizing performance by caching function results.", "Redux state management.", "Lifecycle optimization."], "answer": "b", "explanation": "Memoization avoids unnecessary re-renders by caching computations or components."},
	{"id": 56, "category": "Testing & Performance", "question": "What is React.memo?", "options": ["A hook.", "A higher-order component that memoizes functional components.", "A lifecycle method.", "A Redux action."], "answer": "b", "explanation": "React.memo optimizes functional components by re-rendering only if props change."},
	{"id": 57, "category": "Testing & Performance", "question": "What is useCallback used for?", "options": ["Memoizing functions.", "Memoizing values.", "Handling refs.", "Redux actions."], "answer": "a", "explanation": "useCallback memoizes callback functions to avoid unnecessary re-creations."},
	{"id": 58, "category": "Testing & Performance", "question": "What is useMemo used for?", "options": ["Memoizing values from expensive calculations.", "Memoizing functions.", "Redux actions.", "Lifecycle hooks."], "answer": "a", "explanation": "useMemo caches computed values, recalculating only when dependencies change."},
	{"id": 59, "category": "Testing & Performance", "question": "What is server-side rendering (SSR) in React?", "options": ["Rendering components in the database.", "Rendering components on the server before sending HTML to the browser.", "Rendering only on the client.", "Rendering CSS on backend."], "answer": "b", "explanation": "SSR improves performance and SEO by pre-rendering React components on the server."},
	{"id": 60, "category": "Testing & Performance", "question": "What is hydration in React?", "options": ["Adding water to servers.", "Attaching React event listeners to server-rendered HTML.", "Adding CSS to components.", "Loading Redux state."], "answer": "b", "explanation": "Hydration attaches React’s event system to HTML rendered by SSR, making it interactive."},
	{"id": 61, "category": "React 18 & Concurrent", "question": "What is automatic batching in React 18?", "options": ["Combining multiple CSS files into one.", "Grouping multiple state updates across async boundaries into a single render.", "Bundling code for production.", "Merging props and state automatically."], "answer": "b", "explanation": "React 18 automatically batches state updates inside timeouts, promises, and native event handlers, reducing unnecessary re-renders."},
	{"id": 62, "category": "React 18 & Concurrent", "question": "What does useTransition do?", "options": ["Creates a new CSS transition.", "Marks a state update as non-urgent to keep the UI responsive.", "Delays component mounting.", "Forces synchronous rendering."], "answer": "b", "explanation": "useTransition lets you mark updates as transitions so urgent updates (like typing) stay responsive while non-urgent UI updates can be deferred."},
	{"id": 63, "category": "React 18 & Concurrent", "question": "When would you use useDeferredValue?", "options": ["To memoize function references.", "To defer re-rendering of an expensive value until the main updates have finished.", "To fetch data on mount.", "To create refs for DOM nodes."], "answer": "b", "explanation": "useDeferredValue lets you show the previous value while deferring expensive recalculations, improving perceived performance during fast input."},
	{"id": 64, "category": "Rendering", "question": "What are the two phases of React rendering?", "options": ["Build and Deploy.", "Render (reconciliation) and Commit.", "Mount and Unmount only.", "Fetch and Display."], "answer": "b", "explanation": "React first renders to compute changes (render phase) and then applies changes to the DOM (commit phase)."},
	{"id": 65, "category": "State Management", "question": "Why should state updates be immutable in React?", "options": ["To enable automatic garbage collection.", "So React can detect changes via reference equality and optimize re-renders.", "Because JavaScript forbids mutation.", "To make code shorter."], "answer": "b", "explanation": "Immutability ensures new references on changes, allowing React and memoization to detect updates efficiently."},
	{"id": 66, "category": "State Management", "question": "When should you use the functional form of setState/useState updater?", "options": ["When the next state depends on the previous state.", "When updating props.", "When using Context.", "When rendering portals."], "answer": "a", "explanation": "Use setState(prev => next) to avoid stale closures when computing next state from the previous state."},
	{"id": 67, "category": "Keys & Lists", "question": "Why are keys important in lists?", "options": ["They style list items.", "They help React identify which items changed, are added, or removed.", "They provide security.", "They sort the list automatically."], "answer": "b", "explanation": "Stable, unique keys enable efficient reconciliation and prevent incorrect DOM re-use."},
	{"id": 68, "category": "Keys & Lists", "question": "Why is using array index as a key discouraged?", "options": ["It throws a runtime error.", "It increases bundle size.", "It can cause UI inconsistencies when list order changes or items are inserted/removed.", "It disables memoization."], "answer": "c", "explanation": "Index keys don’t uniquely identify items across operations, leading to incorrect state association after reordering."},
	{"id": 69, "category": "Effects", "question": "What is the difference between useEffect and useLayoutEffect?", "options": ["They are identical.", "useLayoutEffect runs synchronously after DOM mutations; useEffect runs asynchronously after paint.", "useEffect runs before render; useLayoutEffect runs after unmount.", "useLayoutEffect is only for class components."], "answer": "b", "explanation": "useLayoutEffect fires before the browser paints, useful for measuring/layout; useEffect runs after paint and is non-blocking."},
	{"id": 70, "category": "Effects", "question": "How do you perform cleanup in useEffect?", "options": ["By calling cleanup() after setState.", "Return a function from the effect that React calls on unmount or before re-running the effect.", "Using try/catch.", "With React.Cleanup API."], "answer": "b", "explanation": "Effects may return a cleanup function to unsubscribe, cancel timers, or revert DOM changes."},
	{"id": 71, "category": "Refs & DOM", "question": "What is the purpose of useRef?", "options": ["To create global state.", "To hold a mutable value that persists across renders without causing re-renders.", "To fetch data.", "To memoize computations."], "answer": "b", "explanation": "useRef stores a mutable .current value (like DOM nodes or instance variables) that doesn’t trigger renders when changed."},
	{"id": 72, "category": "Refs & DOM", "question": "What does forwardRef enable?", "options": ["Server-side rendering.", "Passing refs through a component to its child.", "Lazy loading.", "Type checking props."], "answer": "b", "explanation": "React.forwardRef lets components expose a child’s ref to parents, useful for input focusing and imperative APIs."},
	{"id": 73, "category": "Refs & DOM", "question": "When would you use useImperativeHandle?", "options": ["To optimize reducers.", "To customize the instance value exposed to parent refs.", "To create context providers.", "To batch state updates."], "answer": "b", "explanation": "useImperativeHandle with forwardRef allows a component to control what methods/values are accessible via its ref."},
	{"id": 74, "category": "Error Handling", "question": "What is an Error Boundary in React?", "options": ["A CSS rule.", "A component that catches JavaScript errors in its child tree during render and commit.", "A Redux middleware.", "A router guard."], "answer": "b", "explanation": "Error Boundaries (class components implementing componentDidCatch/getDerivedStateFromError) prevent the whole app from crashing."},
	{"id": 75, "category": "Portals", "question": "What are React Portals used for?", "options": ["To optimize images.", "To render children into a DOM node outside the parent DOM hierarchy.", "To manage state globally.", "To fetch data faster."], "answer": "b", "explanation": "Portals let you render modals, tooltips, etc., into separate DOM nodes while preserving React tree context and events."},
	{"id": 76, "category": "Context", "question": "How can Context negatively affect performance?", "options": ["It disables SSR.", "Any context value change re-renders all consuming components unless memoized or split.", "It breaks keys in lists.", "It duplicates state."], "answer": "b", "explanation": "Because all consumers subscribe to the same context, updates propagate widely; mitigate with memoization or context splitting."},
	{"id": 77, "category": "Memoization", "question": "What does useMemo prevent?", "options": ["Network requests.", "Recalculation of expensive values when dependencies have not changed.", "DOM updates.", "State updates."], "answer": "b", "explanation": "useMemo caches computed results and recomputes only when its dependency array changes."},
	{"id": 78, "category": "Memoization", "question": "When is React.memo most effective?", "options": ["When props change every render.", "When props are stable and the component is pure, avoiding unnecessary re-renders.", "For class components only.", "When using Redux only."], "answer": "b", "explanation": "React.memo works best for pure components receiving the same props frequently; it skips rendering if props are shallow equal."},
	{"id": 79, "category": "Data Fetching & Suspense", "question": "What does Suspense for data fetching provide?", "options": ["Automatic REST endpoints.", "A declarative way to show fallback UI while data is loading.", "WebSocket connections.", "CSS transitions."], "answer": "b", "explanation": "Suspense coordinates asynchronous data fetching with fallback boundaries for a smoother loading experience."},
	{"id": 80, "category": "Data Fetching & Suspense", "question": "What is a Suspense boundary?", "options": ["A routing guard.", "A component that wraps children and displays a fallback while descendants are 'suspended'.", "A testing utility.", "A CSS container."], "answer": "b", "explanation": "<Suspense fallback={...}> shows fallback content until children resolve (e.g., data or lazy components)."},
	{"id": 81, "category": "SSR", "question": "What is streaming SSR in React?", "options": ["Sending images as streams only.", "Incrementally sending HTML to the client as it's generated, improving TTFB.", "Streaming CSS.", "A database feature."], "answer": "b", "explanation": "Streaming SSR allows the server to flush chunks of HTML progressively so the client can start rendering earlier."},
	{"id": 82, "category": "APIs", "question": "What replaced ReactDOM.render in React 18?", "options": ["renderRoot.", "createRoot and root.render.", "hydrateRoot only.", "useRender."], "answer": "b", "explanation": "React 18 introduced the root API: const root = createRoot(container); root.render(<App />)."},
	{"id": 83, "category": "Strict Mode", "question": "What special behavior happens in StrictMode in development?", "options": ["Components are skipped.", "Effects' setup functions may run twice to help detect side effects.", "Props are frozen.", "All console logs are removed."], "answer": "b", "explanation": "StrictMode intentionally double-invokes certain lifecycle methods/effects in dev to surface unexpected side effects."},
	{"id": 84, "category": "Forms", "question": "What is a controlled input?", "options": ["An input managed by the DOM only.", "An input whose value is driven by React state via the value prop and onChange handler.", "An input controlled by CSS.", "An input stored in localStorage only."], "answer": "b", "explanation": "Controlled inputs mirror state; updates come from onChange handlers updating state, then value reflects state."},
	{"id": 85, "category": "Forms", "question": "How do you prevent losing cursor position in controlled inputs?", "options": ["Use alerts.", "Avoid unnecessary re-renders and ensure value changes only when needed (e.g., debounce or memoize).", "Use array index as key.", "Disable StrictMode."], "answer": "b", "explanation": "Frequent re-renders or recreating input nodes can reset caret position; keep keys stable and avoid needless updates."},
	{"id": 86, "category": "Events", "question": "What are Synthetic Events in React?", "options": ["Browser-native events without wrappers.", "A cross-browser wrapper around native events providing a consistent interface.", "Server events only.", "WebSocket events only."], "answer": "b", "explanation": "React normalizes events into SyntheticEvent for consistency across browsers."},
	{"id": 87, "category": "Optimization", "question": "What is the main purpose of splitting components?", "options": ["To increase file count.", "To improve readability, reusability, and enable selective re-renders.", "To enable CSS modules.", "To reduce bundle size only."], "answer": "b", "explanation": "Smaller components are easier to reason about and optimize; only affected subtrees re-render."},
	{"id": 88, "category": "Props & Children", "question": "What is the children prop?", "options": ["A built-in prop that represents nested elements inside a component.", "A special CSS slot.", "A Redux feature.", "A DOM API."], "answer": "a", "explanation": "children holds the JSX passed between a component’s opening and closing tags."},
	{"id": 89, "category": "Custom Hooks", "question": "What is a custom hook?", "options": ["A class method.", "A function starting with use that encapsulates reusable stateful logic.", "A CSS helper.", "A Node.js module."], "answer": "b", "explanation": "Custom hooks let you share logic between components by composing other hooks."},
	{"id": 90, "category": "Custom Hooks", "question": "What is a key rule when writing custom hooks?", "options": ["They must call hooks conditionally.", "They must start with the prefix 'use' and follow the Rules of Hooks.", "They must return JSX.", "They must be classes."], "answer": "b", "explanation": "Starting with 'use' allows lint rules to enforce correct usage; custom hooks can call other hooks but must keep call order stable."},
	{"id": 91, "category": "TypeScript", "question": "How do you type React component props in TypeScript?", "options": ["Using PropTypes only.", "By defining a Props interface/type and annotating the component's props parameter.", "Typing state only.", "No typing is needed."], "answer": "b", "explanation": "Define interface Props { ... } and use function Comp(props: Props) { ... } or React.FC<Props>."},
	{"id": 92, "category": "TypeScript", "question": "What is the type of the children prop in TypeScript?", "options": ["string only.", "ReactNode.", "HTMLElement.", "any only."], "answer": "b", "explanation": "children is commonly typed as React.ReactNode to accept a wide range of renderable values."},
	{"id": 93, "category": "Performance", "question": "What is React's re-render trigger?", "options": ["Calling console.log.", "Changes in state, props, or context.", "Network requests finishing.", "CSS animations."], "answer": "b", "explanation": "React re-renders a component when its state, props, or consumed context values change."},
	{"id": 94, "category": "Performance", "question": "What is prop drilling?", "options": ["Passing props deeply through many levels of components.", "Fetching props from the server.", "Drilling holes in code.", "A testing technique."], "answer": "a", "explanation": "Prop drilling refers to passing data through intermediate components that don't need it; Context or composition can reduce it."},
	{"id": 95, "category": "Routing", "question": "Why does React Router use client-side routing?", "options": ["To disable SEO.", "To navigate without full page reloads, preserving state and improving UX.", "To force server rendering only.", "Because HTML links are deprecated."], "answer": "b", "explanation": "Client-side routers intercept navigation events and update the history and UI without reloading the page."},
	{"id": 96, "category": "Build & Code Splitting", "question": "How do you lazy-load a component in React?", "options": ["With require().", "Using React.lazy(() => import('...')) with Suspense.", "By adding defer to script tags.", "Using setTimeout."], "answer": "b", "explanation": "React.lazy loads components on demand and must be wrapped in a Suspense boundary for fallback UI."},
	{"id": 97, "category": "Testing", "question": "What should you test in React components?", "options": ["Implementation details only.", "User-observable behavior and accessible queries (getByRole, etc.).", "Private variables.", "DevTools output."], "answer": "b", "explanation": "RTL encourages testing components the way users interact with them, focusing on behavior and accessibility."},
	{"id": 98, "category": "Accessibility", "question": "How can you improve accessibility in React apps?", "options": ["Avoid semantic HTML.", "Use semantic elements, ARIA attributes when needed, proper labels, and keyboard navigation.", "Use divs only.", "Disable tab navigation."], "answer": "b", "explanation": "Accessible apps use semantic HTML, labeled controls, correct roles, and ensure everything is reachable via keyboard."},
	{"id": 99, "category": "Best Practices", "question": "Where should data fetching generally occur in React?", "options": ["In random utility files.", "Inside effects or event handlers within components or within custom hooks.", "In CSS files.", "Only in index.html."], "answer": "b", "explanation": "Fetch data within components (useEffect) or custom hooks tied to the component lifecycle and UI events."},
	{"id": 100, "category": "Best Practices", "question": "What is the purpose of the dependency array in hooks like useEffect?", "options": ["To style components.", "To control when the effect or memoized value/function should re-run based on dependency changes.", "To enable SSR.", "To create contexts."], "answer": "b", "explanation": "Dependencies determine when React should re-run an effect, recompute a memoized value, or recreate a callback."}
]
